<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../css/notes-style.css">
  <style>
    code {
      background-color: lightgray;
    }
  </style>
  <title>Week 07 Notes</title>
</head>

<body>
  <h1>Week 07 Notes</h1>
  <h2>Further Functions</h2>
  <p>The <code>call()</code> method of a function can be used to set the value of <code><em>this</em></code> inside a
    function. </p>

  <p>Example:
    <pre><code>function sayHello(){
  return `Hello, my name is ${this.name}`;
}</code></pre>
  </p>

  <p>We can then use the following to call the function <code>sayHello()</code> and set the value of
    <code><em>this</em></code>
    <pre><code>const clark = {name: 'Clark'};
    sayHello.call(clark);

This then returns 'Hello, my name is Clark'</code></pre>
  </p>

  <p>You can call a function immediatly after invoking it by adding parentheses at the end of the definition. This is
    known as an IIFE.
    <pre><code>(function(){
  const temp = 'World';
  console.log(`Hello ${temp}`);
  })();</code></pre>
  </p>
  <p>A <em><b>promise</b></em> represents the future result of an asynchronous operation.</p>
  <h4>Pure Functions</h4>
  <p>There are 3 fundimental rules to functional programming and using pure functions.
    <ol>
      <li>The return value should only depend on the values provided as arguments. It should not rely on values from
        elsewhere in the program.</li>
      <li>No side-effects from the function, it should not affect or change anything elsewhree in the program. </li>
      <li>Transparency, if you give the argument it should always return the same result. </li>
    </ol>
    They should always have at least one argument and a return value, otherwise they brak the first and second rule of
    Pure Functions.
  </p>
  <h2>AJAX</h2>
  <p>The new method for using AJAX is not XMLHttpRequests like we have done in previous classes, now there is the
    <code>fetch()</code> API method which helps solve many of the issues
    expereinced with XMLHttpRequests and helps to streamline many of the concepts.</p>
  <p>To create an HTTP request using the fetch() method you will need to use a constuctor function. Here is an example:
    <pre><code>const request = new Request('https://example.com/data', {
  method:'GET',
  mode: 'cors',
  redirect: 'follow',
  cache: 'no-cache'
}); </code></pre> Once the request object is assigned to a variable (in this case <em><b>request</b></em>) it can be
    used as the parameter of the <code>fetch()</code> method</p>
  <p>Another method to approch this is to jsut include the URL and opbect directly as the argumnets of
    <code>fectch()</code>
    Example:
    <pre><code>fetch('https://example.com/data', {
  method:'GET',
  mode: 'cors',
  redirect: 'follow',
  cache: 'no-cache'
});
.then(// Do something with the response)
.catch(// Handle any errors from the request)</code></pre></p>
  <p>One thing that stands out to me about this new method of using the Fetch API instead of the XMLHttpRequests is that it seems a lot easier to manage and 
    keep track of everything. I like that almost all of the examples they give in the reading show how to do this using constructors and storing those 
    in variables. That makes it so much easier to read and understand.
  </p>
  <p>Headers are used to specify additional information about the request and response. The headers object has several built in methods that we can use: <code>has(), get(), set(), append(), delete(), and 3 loop methods[keys(), values() and entries()]</code></p>
  <p><h5>Example of a typical set up for a request using Headers, Requests and Response objects:</h5> <pre><code>const url = 'https:example.com/data';
  const headers = new Headers({ 'Content-Type': 'text/plain', 
  'Accept-Charset' : 'utf-8', 'Accept-Encoding':'gzip,deflate' })
  const request = (url,{
      headers: headers
  })
  fetch(request)
  .then( function(response) {
      if(response.ok) {
          return response;
      }
      throw Error(response.statusText);
  })
  .then( response => // do something with response )
  .catch( error => console.log('There was an error!') )</code></pre></p>

  <h3>Example of fetch using text and JSON data from chapter reading</h3>
  <button id="number">Get Numbers</button>
  <button id="chuck">Get Random Fact</button>
  <div id="output">
    Ajax response will appear here
  </div>

  <h4>FormData</h4>
  <p>The Fetch API includes the FormData interface, which makes it much easier to submit information in forms using Ajax. When you pass the form data to the constuctor fucntion as an argumnet the function will serialize all the data automatically, so it is ready to be sent with AJAX. <em>The helps to limit the amount of code needed to send forms.</em> By using the Fetch API we are helping to develop future standards.</p>


  <script src="main.js"></script>

</body>

</html>